事务的核心是锁和并发的结合体。比锁和并发更容易理解的方式展示。

锁和并发，事务追求的用户容易理解。

降低锁的颗粒度，要辨析哪里加锁，加大了编程难度。

事务保证一致性，要么。。。要么。。。多线程看见得问题。

一个Lock就可以实现ACID。
ACID理解转账过程。

事务单元：1 转账  2 商品建立GMT_Modified索引 3 DB内读取一行记录 4 DB内写入一行数据，同时更新
5 删除整张表  所有对DB一个操作，都是一个事务。

一组事务单元：事务单元和事务单元关系

为什么有了一致又有了隔离级别？

读读，读写优化，写读优化，

人类对数据库事务优化到了很高的优化。

实现并发度高。

事务处理技术:
全部顺序，读写锁，MVCC。

转账：先锁两个账户。

数据库隔离级别本质是请求并行技术。TPCC非常高。

并行度优化。

数据库为什么提出事务这个概念？多个不同命令组装在一起。Synchrnized代码块就是事务，数据库事务单元
处理很多。数据库要记录日志，保证不丢失，保证持久性。

持久性：事务提交了，绝对不对丢了。

怎么保证数据不丢失？

每次Commit都去刷磁盘，包括NoSQL，仔细权衡。

持久性和延迟的权衡。

所有请求提交内存，直接返回。对磁盘友好，块存储，块越大，发挥磁盘吞吐能力。

Redis TPS和持久化策略有关系的。

刷benchmark保证这么配置。

问题本质在于在内存攒一个块，Group Commit。组提交会延迟。
组提交：IOPS会慢，吞吐量提高了。
IOPS快，缩短组提交时间。吞吐量大，组提交大。

IOPS和吞吐量跷跷板。快速设备和慢速设备之间协调问题。CPU和内存也会有一样问题。

ACID尽可能帮你提高并行度。

计算机没有魔法，只是打字机，只会顺序打LOVE，系统并行度上不来都是这些。
两个人同时用一打字机，会有冲突。解决冲突：1 乐观 2 悲观  
解决本质：让两个人不同时打印。

计算机就是打字机。一次只能打一个字母，打单词的话，

mysql recover：https://www.cnblogs.com/liuhao/p/3714012.html

任何系统对异常处理会复杂。

事务调优原则(和共享变量调优一样):
减少锁范围，增加锁上线程数，锁类型。

所有性能调优放之四海准：

悲观锁：数据加锁，线程会blocked，cpu不会调度你了，从blocked到原始状态，等待runnable，
等待通知。切换回去在切换回来。
本质：看下有没有做的事情，没有就等。寄存器数据数据换下来，换成另外线程，缓存清空，
CPU cache清空，增加系统开销，反而减少系统开销，因为会一直查看CPU。

争抢严重：悲观锁， 争抢不严重：乐观锁。

MVCC：全是写，MVCC记录很多日志，会增加系统延迟，并行读取，读写比较高，读写比例低，
MVCC反而不合适。

系统宕机恢复过程。

读写锁可以实现读已提交和可重复读。

共享（S)锁  排它（X)锁  更新（U)锁
死锁扩展：U锁，更新锁。

同一个数据库，发了请求，基本上都是事务，Begin，Commit 也是事务单元。

事务单元 映射回到锁实现，2PL上世纪实现，MVCC这个时代。

通过锁实现事务单元概念。

读写锁死锁。

数据库复杂，因为对并发进行了很多优化。

MVCC 写写可以并行。乐观和悲观。

事务间没有感知，一步一步更新数据可能出现状态变化。

乐观并发：版本低的并发更新回滚，并发高失败率低，需要不断重试。
写写并行。如果知道冲突了，想办法回滚过去。

分布式数据库-》分布式事务

网络不可达，tcp关闭连接时候要等待两倍时间呢？

分布式系统不能共享数据，如果不共享，就要进行消息传递，数据复制，但是有延迟。消息传递导致系统延迟。

分布式系统，去中心化系统，面临并发编程难度。

阿里沈询：分布式事务原理与实践
http://jm.taobao.org/2017/02/09/20170209/

分布式事务视频：https://yq.aliyun.com/articles/69211







